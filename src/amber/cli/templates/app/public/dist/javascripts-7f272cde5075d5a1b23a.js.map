{"version":3,"file":"javascripts-7f272cde5075d5a1b23a.js","sources":["webpack:///webpack/bootstrap a1a273adf149d4b33ef7","webpack:///src/assets/javascripts/main.js","webpack:///../amber/assets/js/amber.js","webpack:///./src/assets/images ^\\.\\/.*$","webpack:///./src/assets/images/logo.png","webpack:///./src/assets/fonts ^\\.\\/.*$"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a1a273adf149d4b33ef7","var context = require.context('../images', true) // Necessary for asset helper.  Has webpack import all the images regardless of use in js/css.\nvar context = require.context('../fonts', true) // Necessary for asset helper.  Has webpack import all the fonts regardless of use in js/css.\nimport Amber from 'amber'\n\n\n\n// WEBPACK FOOTER //\n// src/assets/javascripts/main.js","const EVENTS = {\n  join: 'join',\n  leave: 'leave',\n  message: 'message'\n}\nconst STALE_CONNECTION_THRESHOLD_SECONDS = 100\nconst SOCKET_POLLING_RATE = 10000\n\n/**\n * Returns a numeric value for the current time\n */\nlet now = () => {\n  return new Date().getTime()\n}\n\n/**\n * Returns the difference between the current time and passed `time` in seconds\n * @param {Number|Date} time - A numeric time or date object\n */\nlet secondsSince = (time) => {\n  return (now() - time) / 1000\n}\n\n/**\n * Class for channel related functions (joining, leaving, subscribing and sending messages)\n */\nexport class Channel {\n  /**\n   * @param {String} topic - topic to subscribe to\n   * @param {Socket} socket - A Socket instance\n   */\n  constructor(topic, socket) {\n    this.topic = topic\n    this.socket = socket\n    this.onMessageHandlers = []\n  }\n\n  /**\n   * Join a channel, subscribe to all channels messages\n   */\n  join() {\n    this.socket.ws.send(JSON.stringify({ event: EVENTS.join, topic: this.topic }))\n  }\n\n  /**\n   * Leave a channel, stop subscribing to channel messages\n   */\n  leave() {\n    this.socket.ws.send(JSON.stringify({ event: EVENTS.leave, topic: this.topic }))\n  }\n\n  /**\n   * Calls all message handlers with a matching subject\n   */\n  handleMessage(msg) {\n    this.onMessageHandlers.forEach((handler) => {\n      if (handler.subject === msg.subject) handler.callback(msg.payload)\n    })\n  }\n\n  /**\n   * Subscribe to a channel subject\n   * @param {String} subject - subject to listen for: `msg:new`\n   * @param {function} callback - callback function when a new message arrives\n   */\n  on(subject, callback) {\n    this.onMessageHandlers.push({ subject: subject, callback: callback })\n  }\n\n  /**\n   * Send a new message to the channel\n   * @param {String} subject - subject to send message to: `msg:new`\n   * @param {Object} payload - payload object: `{message: 'hello'}`\n   */\n  push(subject, payload) {\n    this.socket.ws.send(JSON.stringify({ event: EVENTS.message, topic: this.topic, subject: subject, payload: payload }))\n  }\n}\n\n/**\n * Class for maintaining connection with server and maintaining channels list\n */\nexport class Socket {\n  /**\n   * @param {String} endpoint - Websocket endpont used in routes.cr file\n   */\n  constructor(endpoint) {\n    this.endpoint = endpoint\n    this.ws = null\n    this.channels = []\n    this.lastPing = now()\n    this.reconnectTries = 0\n    this.attemptReconnect = true\n  }\n\n  /**\n   * Returns whether or not the last received ping has been past the threshold\n   */\n  _connectionIsStale() {\n    return secondsSince(this.lastPing) > STALE_CONNECTION_THRESHOLD_SECONDS\n  }\n\n  /**\n   * Tries to reconnect to the websocket server using a recursive timeout\n   */\n  _reconnect() {\n    clearTimeout(this.reconnectTimeout)\n    this.reconnectTimeout = setTimeout(() => {\n      this.reconnectTries++\n      this.connect(this.params)\n      this._reconnect()\n    }, this._reconnectInterval())\n  }\n\n  /**\n   * Returns an incrementing timeout interval based around the number of reconnection retries\n   */\n  _reconnectInterval() {\n    return [1000, 2000, 5000, 10000][this.reconnectTries] || 10000\n  }\n\n  /**\n   * Sets a recursive timeout to check if the connection is stale\n   */\n  _poll() {\n    this.pollingTimeout = setTimeout(() => {\n      if (this._connectionIsStale()) {\n        this._reconnect()\n      } else {\n        this._poll()\n      }\n    }, SOCKET_POLLING_RATE)\n  }\n\n  /**\n   * Clear polling timeout and start polling\n   */\n  _startPolling() {\n    clearTimeout(this.pollingTimeout)\n    this._poll()\n  }\n\n  /**\n   * Sets `lastPing` to the curent time\n   */\n  _handlePing() {\n    this.lastPing = now()\n  }\n\n  /**\n   * Clears reconnect timeout, resets variables an starts polling\n   */\n  _reset() {\n    clearTimeout(this.reconnectTimeout)\n    this.reconnectTries = 0\n    this.attemptReconnect = true\n    this._startPolling()\n  }\n\n  /**\n   * Connect the socket to the server, and binds to native ws functions\n   * @param {Object} params - Optional parameters\n   * @param {String} params.location - Hostname to connect to, defaults to `window.location.hostname`\n   * @param {String} parmas.port - Port to connect to, defaults to `window.location.port`\n   * @param {String} params.protocol - Protocol to use, either 'wss' or 'ws'\n   */\n  connect(params) {\n    this.params = params\n\n    let opts = {\n      location: window.location.hostname,\n      port: window.location.port,\n      protocol: window.location.protocol === 'https:' ? 'wss:' : 'ws:',\n    }\n\n    if (params) Object.assign(opts, params)\n    if (opts.port) opts.location += `:${opts.port}`\n\n    return new Promise((resolve, reject) => {\n      this.ws = new WebSocket(`${opts.protocol}//${opts.location}${this.endpoint}`)\n      this.ws.onmessage = (msg) => { this.handleMessage(msg) }\n      this.ws.onclose = () => {\n        if (this.attemptReconnect) this._reconnect()\n      }\n      this.ws.onopen = () => {\n        this._reset()\n        resolve()\n      }\n    })\n  }\n\n  /**\n   * Closes the socket connection permanently\n   */\n  disconnect() {\n    this.attemptReconnect = false\n    clearTimeout(this.pollingTimeout)\n    clearTimeout(this.reconnectTimeout)\n    this.ws.close()\n  }\n\n  /**\n   * Adds a new channel to the socket channels list\n   * @param {String} topic - Topic for the channel: `chat_room:123`\n   */\n  channel(topic) {\n    let channel = new Channel(topic, this)\n    this.channels.push(channel)\n    return channel\n  }\n\n  /**\n   * Message handler for messages received\n   * @param {MessageEvent} msg - Message received from ws\n   */\n  handleMessage(msg) {\n    if (msg.data === \"ping\") return this._handlePing()\n\n    let parsed_msg = JSON.parse(msg.data)\n    this.channels.forEach((channel) => {\n      if (channel.topic === parsed_msg.topic) channel.handleMessage(parsed_msg)\n    })\n  }\n}\n\nmodule.exports = {\n  Socket: Socket\n}\n\n\n\n// WEBPACK FOOTER //\n// ../amber/assets/js/amber.js","var map = {\n\t\"./logo.png\": 3\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\tvar id = map[req];\n\tif(!(id + 1)) // check for number or string\n\t\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\n\treturn id;\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 2;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/assets/images ^\\.\\/.*$\n// module id = 2\n// module chunks = 0","module.exports = __webpack_public_path__ + \"images/logo-c321a05deb5e6e097a40ecffbf90de45.png\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/assets/images/logo.png\n// module id = 3\n// module chunks = 0","function webpackEmptyContext(req) {\n\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 4;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/assets/fonts ^\\.\\/.*$\n// module id = 4\n// module chunks = 0"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC3DA;AACA;;;AAHA;AACA;AACA;AADA;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AAHA;AAKA;AACA;AAEA;;;;AAGA;AACA;AACA;AAEA;;;;;;AAIA;AACA;AACA;AAEA;;;;;AAGA;;;AACA;;;;AAIA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;;;;;AAGA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;;;;;;AAGA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;;;;;;AAGA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAKA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;;;;;;;;AAKA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;AAGA;;;;;;;AAGA;;;AACA;;;AAGA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAGA;AACA;AACA;AAEA;;;;;;AAGA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;;;;;;AAGA;AACA;AACA;AAEA;;;;;;AAGA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAGA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AAGA;AACA;AACA;AAEA;;;;;;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;;;;AAOA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAHA;AAMA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;AAGA;AACA;AADA;;;;;;ACjOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACjBA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;A","sourceRoot":""}